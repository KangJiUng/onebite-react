## 섹션 2: 자바스크립트 심화

- 자바스크립트에서는 참, 거짓이 아닌 값도 참, 거짓으로 평가한다.
  - Truthy한 값 / Falsy한 값
- 자바스크립트의 단락평가
  - 논리연산자의 첫 번째 피연산자의 값만으로도 값을 평가할 수 있는 경우 그 뒤의 피연산자는 접근조차 하지 않는다.
- 자바스크립트의 구조 분해 할당
  - 배열의 요소들을 분해해서 할당
- Spread 연산자: 객체나 배열에 저장된 여러 개의 값을 개별로 흩뿌려주는 역할

```jsx
let arr1 = [1, 2, 3];
let arr2 = [4, ...arr1, 5, 6];

let obj1 = {
  a: 1,
  b: 2,
};
let obj2 = {
  ...obj1,
  c: 3,
  d: 4,
};

function funcA(p1, p2, p3) {
  //   console.log(p1, p2, p3);
}

funcA(...arr1);
```

- Rest 매개변수: Rest는 나머지 → 나머지 매개변수
  - Rest 매개변수 뒤에는 추가 매개변수 올 수 없음

```jsx
function funcB(one, two, ...ds) {
  console.log(ds);
}

funcB(...arr1);
```

- 자바스크립트의 자료형 원시타입과 객체타입은 값이 저장되거나 복사되는 과정이 다르다.

  - 원시타입: 값 자체로써 변수에 저장되고 복사된다.
    - 타입의 값을 바꿔도 원본의 실제 메모리의 값은 수정되지 않음(불변값)
  - 객체타입: 참조값을 통해 변수에 저장되고 복사된다.

    - 타입의 값을 바꾸면 그 메모리에 참조되는 값 자체를 수정함(가변값)
    - 의도치 않게 값이 수정될 수 있음에 주의(Side Effect)
      - 얕은 복사: 객체의 참조값을 복사함(Side Effect 위험 O)
      - 깊은 복사: 새로운 객체를 생성하면서 프로퍼티만 따로 복사함(Side Effect 위험 X)
    - 객체간의 비교는 기본적으로 참조값을 기준으로 이루어진다.
      - 얕은 비교: 참조값을 기준으로 비교
      - 깊은 비교: 객체를 문자열로 변환하여 비교(프로퍼티 값 기준 비교)
        - JSON.stringify(): 객체를 문자열로 변환하는 기능
    - 배열과 함수도 사실 객체이다.

    ```jsx
    let o1 = { name: "홍길동" }
    let o2 = o1; // 얕은 복사

    // o2의 값도 강지웅으로 변경됨
    o2.name = "강지웅";

    ---

    let o1 = { name: "홍길동" }
    // 새로운 객체 생성
    let o2 = { ...o1 }; // 깊은 복사

    // o1과 o2의 name값이 달라짐
    o2.name = "강지웅";

    ---

    let o1 = { name: "홍길동" };
    let o2 = o1;
    let o3 = { ...o1 };

    // 얕은 비교
    console.log(o1 === o2); // True
    console.log(o1 === o2); // False

    // 깊은 비교
    console.log(
    	JSON.stringify(o1) === JSON.stringify(o3)
    ); // True
    ```

- 객체 순회 하기

  - Object.keys(): 객체에서 key 값들만 뽑아서 새로운 배열로 반환
  - Object.values(): 객체에서 value 값들만 뽑아서 새로운 배열로 반환
  - 배열 순회는 of, 객체 순회는 in 사용에 유의

- 요소 조작 메서드

  - pop(): 배열의 맨 뒤에 있는 요소를 제거하고, 반환
  - push(): 배열의 맨 뒤에 새로운 요소를 추가하는 메서드
  - shift(): 배열의 맨 앞에 있는 요소를 제거, 반환
    - pop()에 비해 속도 느림
  - unshift(): 배열의 맨 앞에 새로운 요소를 추가하는 메서드
    - push()에 비해 속도 느림
  - slice(): 배열의 특정 범위를 잘라내서 새로운 배열로 반환
    - 원본 배열의 값은 바뀌지 않음
  - concat(): 두 개의 서로 다른 배열을 이어 붙여서 새로운 배열을 반환

- 요소 순회 및 탐색 메서드

  - forEach(): 모든 요소를 순회하면서, 각각의 요소에 특정 동작을 수행시키는 메서드
  - includes(): 배열에 특정 요소가 있는지 확인하는 메서드
  - indexOf(): 특정 요소의 인덱스(위치)를 찾아서 반환하는 메서드
    - 기본적으로 얕은 비교를 수행하기 때문에, 원시타입이 아닌 객체타입인 경우에는 제대로 작동하지 않음
  - findIndex(): 모든 요소를 순회하면서, 콜백함수를 만족하는 특정 요소의 인덱스(위치)를 반환하는 메서드
    - 복잡한 객체타입을 순회할 때 사용
  - find(): 모든 요소를 순회하면서 콜백함수를 만족하는 요소를 찾는데, 요소를 그대로 반환

- 배열 변형 메서드

  - filter(): 기존 배열에서 조건을 만족하는 요소들만 필터링하여 새로운 배열로 반환
  - map(): 배열의 모든 요소를 순회하면서, 각각 콜백함수를 실행하고 그 결과값들을 모아서 새로운 배열로 반환
  - sort(): 배열을 사전순으로 정렬하는 메서드
    - 숫자로 이루어진 배열의 경우, 우리가 원하는대로(오름차순) 정렬되지 않음
  - toSorted(): 정렬된 새로운 배열을 반환하는 메서드
    - 비교적 가장 최근에 추가된 최신 함수
  - join(): 배열의 모든 요소를 하나의 문자열로 합쳐서 반환하는 메서드

- 자바스크립트의 월은 0부터 시작

- 자바스크립트는 기본적으로 동기적으로 코드를 실행한다.

  - ‘동기’란 여러 개의 작업을 순서대로, 하나씩 처리하는 방식
  - 자바는 C# 같은 언어에서는 동기 방식의 치명적인 단점을 해결하기 위해 멀티쓰레드를 사용하지만, 자바스크립트 엔진에는 쓰레드가 하나뿐 → 비동기로 해결

- 자바스크립트는 쓰레드가 1개인데, 어떻게 동시에 작업을 처리하는 걸까?

  - 비동기 작업들은 자바스크립트 엔진이 아닌 Web APIs 에서 실행된다.
    - Web APIs: 웹 브라우저가 직접 관리하는 별도의 영역

- 인덴트(indent)가 깊어길수록 가독성이 안좋아짐

  - 자바스크립트에서는 특별히 ‘콜백 지옥’이라고 부름 → Promise 사용

- Promise

  - 비동기 작업을 효율적으로 처리할 수 있도록 도와주는 자바스크립트의 내장 객체
  - 비동기 작업을 감싸는 객체
  - Promise의 3가지 상태
    - 대기 (Pending)
      - 성공 (Fullfilled)
      - 실패 (Rejected)
  - resolve(): Promise의 비동기 작업을 성공 시킴 / rejected(): Promise의 비동기 작업을 실패 시킴

    - Promise의 비동기 작업이 성공하면 then() 메서드 실행

      - then() 메서드의 호출 결과는 Promise 객체 그대로 → 바로 뒤에 catch() 메서드를 연결해서 사용 가능(Promise Chaining)

      ```jsx
      Promise
      	.then(value) => {
      		console.log(value);
      	})
      	.catch(error) => {
      		console.log(error);
      	}
      ```

      - then 메서드 안에서 새로운 Promise 객체를 반환해주면 then 메서드의 결과값이 새로운 Promise 객체가 됨 → 콜백지옥 예방

    - Promise의 비동기 작업이 실패하면 catch() 메서드 실행

- 비동기 작업 처리하기
  - 앞서 나온 then 메서드를 사용하지 않아도 간결하게 진행 가능한 방법
  - Async: 어떤 함수를 비동기 함수로 만들어주는 키워드로, 함수가 Promise를 반환하도록 변환해주는 역할
    - 함수가 애초에 Promise를 반환하는 객체라면 Async는 아무런 역할을 하지 않음
  - Await: Async 함수 내부에서만 사용 가능한 키워드로, 비동기 함수가 모두 처리되기를 기다리는 역할
